use std::sync::Arc;

use tower_cookies::{Cookie, Cookies};

use crate::{error::Error, token::CsrfToken, Config};

/// An extension providing a way to interact with a visitor's
/// CSRF token.
#[derive(Clone)]
pub struct CsrfCookie {
    pub(crate) config: Arc<Config>,
    pub(crate) cookies: Cookies,
}

impl CsrfCookie {
    pub(crate) fn new(config: Arc<Config>, cookies: Cookies) -> Self {
        Self { config, cookies }
    }

    /// Create a new CSRF cookie with specified token.
    pub(crate) fn create(&self, token: &CsrfToken) {
        let cookie = Cookie::build((self.config.cookie_name(), token.0.clone()))
            .path("/")
            .expires(self.config.expires)
            .http_only(self.config.http_only)
            .same_site(self.config.same_site)
            .secure(self.config.secure)
            .build();

        self.cookies.add(cookie);
    }

    /// Get the current visitor's token.
    ///
    /// # Errors
    ///
    /// - [`Error::NoCookie`]
    pub fn get(&self) -> Result<CsrfToken, Error> {
        Ok(CsrfToken(
            self.cookies
                .get(&self.config.cookie_name())
                .map(|cookie| cookie.value().to_owned())
                .ok_or(Error::NoCookie)?,
        ))
    }

    /// Reset the token to an identifier generated by [`CsrfLayer`](`crate::csrf::CsrfLayer`).
    pub fn reset(&self) {
        let cookie = Cookie::build((self.config.cookie_name(), "")).build();

        self.cookies.remove(cookie);
    }
}
